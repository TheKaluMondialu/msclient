#!/usr/bin/env python3

"""
Minimal CS 1.6 masterserver (FILE mode only), Python 3.
- Windows and Linux compatible
- Creates required files on first run (ms.cfg, servers_cs.txt)
- Installs optional GeoIP dependency locally into ./vendor on first run (no admin needed)
- Handles Windows UDP errors gracefully (10054 suppressed, 10049 auto-fallback)
- GUI-aware with callback system for real-time updates
- Statistics tracking for monitoring and analytics

GeoIP:
- If [GEOIP] ENABLE=1 (default), tries a MaxMind GeoLite2 .mmdb in the script folder.
- If geoip2 is missing, the script attempts to install it into ./vendor automatically.
- If no DB is found or install fails, falls back to "Unknown" (still runs).

Note: A GeoLite2 database requires a free MaxMind account + license. Place GeoLite2-Country.mmdb or
GeoLite2-City.mmdb next to this script for best results.
"""

import os
import sys
import socket
import time
import threading
import configparser
import random
from datetime import datetime
from typing import Optional, Callable, List, Tuple
import ipaddress
import struct
import platform

# Import statistics module if available
try:
    from stats import Statistics
    HAS_STATS = True
except ImportError:
    HAS_STATS = False
    Statistics = None

# Import database module if available
try:
    from database import ServerDatabase
    HAS_DATABASE = True
except ImportError:
    HAS_DATABASE = False
    ServerDatabase = None

# -------------- Bootstrap: create files and install local deps if needed --------------

DEFAULT_CFG = """# Generated by ms.py on first run
[OPTIONS]
HOST = 0.0.0.0
PORTGS = 27010
REFRESH = 60
NOPING = 0
MODE = database

[FILE]
FILECS = servers_cs.txt
RANDOM = 0

[DATABASE]
DB_PATH = servers.db

[GEOIP]
ENABLE = 1
DB_PATH = GeoLite2-Country.mmdb

[LOG]
ONCE_PER_IP = 1
THROTTLE_SECONDS = 10
"""

DEFAULT_SERVERS = """# Example CS 1.6 servers list (one per line, ip:port). Remove the leading # to activate:
# 127.0.0.1:27015
"""

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
VENDOR_DIR = os.path.join(BASE_DIR, "vendor")


def ensure_files():
    cfg_path = os.path.join(BASE_DIR, "ms.cfg")
    server_path = os.path.join(BASE_DIR, "servers_cs.txt")

    if not os.path.isfile(cfg_path):
        with open(cfg_path, "w", encoding="utf-8") as f:
            f.write(DEFAULT_CFG)
        print("Created default ms.cfg")

    if not os.path.isfile(server_path):
        with open(server_path, "w", encoding="utf-8") as f:
            f.write(DEFAULT_SERVERS)
        print("Created example servers_cs.txt")


def ensure_vendor_on_path():
    if os.path.isdir(VENDOR_DIR) and VENDOR_DIR not in sys.path:
        sys.path.insert(0, VENDOR_DIR)


def try_local_pip_install(packages):
    # Attempt to install packages into ./vendor (works on Windows/Linux without admin)
    try:
        ensure_vendor_on_path()
        import ensurepip  # noqa: F401
        try:
            ensurepip.bootstrap()
        except Exception:
            pass
        import subprocess
        cmd = [sys.executable, "-m", "pip", "install", "--disable-pip-version-check", "--no-input", "--upgrade",
               "--target", VENDOR_DIR] + list(packages)
        print("Installing dependencies locally:", " ".join(packages))
        subprocess.run(cmd, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        ensure_vendor_on_path()
    except Exception:
        # Silent fallback; script can continue without GeoIP
        pass


# -------------- Master server implementation --------------

# Masterserver response header for GoldSrc (CS 1.6)
GOLDSRC_HEADER = bytes([0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0x0A])
# Safety limit to keep UDP packets under typical MTU
MAX_PACKET_SIZE = 1400
# Optional "no ping" trailer. If NOPING == 0 (default), append 6 zero bytes like legacy code
TRAILER_NOPING_OFF = bytes([0x00] * 6)


class MasterServer:
    def __init__(self, cfg_path="ms.cfg", gui_mode=False):
        ensure_files()

        self.gui_mode = gui_mode
        self.cfg = configparser.ConfigParser()
        read = self.cfg.read(os.path.join(BASE_DIR, cfg_path), encoding="utf-8")
        if not read:
            print("Config file ms.cfg not found or unreadable.", file=sys.stderr)
            sys.exit(1)

        # Validate mode
        self.mode = self.cfg.get("OPTIONS", "MODE", fallback="database").strip().lower()
        if self.mode not in ("file", "database"):
            print('MODE must be "file" or "database". Please set [OPTIONS] MODE in ms.cfg', file=sys.stderr)
            sys.exit(1)
        
        # Check if database mode is requested but not available
        if self.mode == "database" and not HAS_DATABASE:
            self._log("WARNING", "Database mode requested but database module not available, falling back to file mode")
            self.mode = "file"

        # Read HOST/PORT and sanitize (accept legacy values and "IP:PORT")
        raw_host = self.cfg.get("OPTIONS", "HOST", fallback="0.0.0.0").strip()
        port_cfg = self.cfg.get("OPTIONS", "PORTGS", fallback="27010").strip()

        # If user mistakenly put "IP:PORT" in HOST, split and override port
        if ":" in raw_host:
            host_part, port_part = raw_host.rsplit(":", 1)
            raw_host = host_part.strip()
            try:
                port_cfg = str(int(port_part.strip()))
                self._log("INFO", f"Detected HOST contained a port; using PORTGS={port_cfg}")
            except Exception:
                pass

        # Coerce legacy/invalid host values
        if raw_host.lower() in ("", "off", "none", "disabled"):
            raw_host = "0.0.0.0"

        self.host = raw_host
        try:
            self.port = int(port_cfg)
        except Exception:
            self.port = 27010

        self.refresh = self.cfg.getint("OPTIONS", "REFRESH", fallback=60)
        self.noping = self.cfg.get("OPTIONS", "NOPING", fallback="0").strip() == "1"

        # File mode settings
        self.file_cs = self.cfg.get("FILE", "FILECS", fallback="servers_cs.txt").strip()
        self.randomize = self.cfg.get("FILE", "RANDOM", fallback="0").strip() == "1"
        
        # Database mode settings
        self.db_path = self.cfg.get("DATABASE", "DB_PATH", fallback="servers.db").strip()
        self.db = None
        
        # Initialize database if in database mode
        if self.mode == "database" and HAS_DATABASE:
            try:
                self.db = ServerDatabase(os.path.join(BASE_DIR, self.db_path))
                self._log("INFO", f"Database mode: connected to {self.db_path}")
            except Exception as e:
                self._log("ERROR", f"Failed to initialize database: {e}")
                self._log("WARNING", "Falling back to file mode")
                self.mode = "file"

        # GeoIP settings
        self.geoip_enabled = self.cfg.get("GEOIP", "ENABLE", fallback="1").strip() == "1"
        self.geoip_db_path = self.cfg.get("GEOIP", "DB_PATH", fallback="GeoLite2-Country.mmdb").strip()

        # Log settings
        self.log_once_per_ip = self.cfg.get("LOG", "ONCE_PER_IP", fallback="1").strip() == "1"
        self.log_throttle_seconds = int(self.cfg.get("LOG", "THROTTLE_SECONDS", fallback="10").strip())

        # Tracking for logging
        self._logged_ips = set()   # used when ONCE_PER_IP=1
        self._log_recent = {}      # ip -> last log monotonic time, used when ONCE_PER_IP=0
        self._log_lock = threading.Lock()

        # GeoIP runtime members
        self.geoip_mode: Optional[str] = None  # "geoip2" | None
        self.geoip_reader = None

        # Statistics tracking
        self.stats = Statistics() if HAS_STATS else None

        # Callback system for GUI integration (must be set BEFORE _init_geoip)
        self.callbacks = {
            "on_log": [],           # (level, message) -> None
            "on_request": [],       # (ip, country) -> None
            "on_server_loaded": [], # (count) -> None
            "on_error": [],         # (error_type, message) -> None
            "on_status_change": [], # (status) -> None
        }

        # Try to install geoip2 locally if enabled and not present
        if self.geoip_enabled:
            try:
                import geoip2  # type: ignore  # noqa
            except Exception:
                try_local_pip_install(["geoip2"])

        self._init_geoip()

        self.sock = None
        self.stop_event = threading.Event()

        # Prepared response packets (list of bytes)
        self.cs_packets = []
        # Lock to protect packet refresh while serving
        self._packet_lock = threading.Lock()

        if self.log_once_per_ip:
            self._log("INFO", "Log mode: once per IP")
        else:
            self._log("INFO", f"Log mode: throttle {self.log_throttle_seconds}s per IP")

    # ----------------- Callback system -----------------

    def register_callback(self, event: str, callback: Callable):
        """Register a callback for GUI events."""
        if event in self.callbacks:
            self.callbacks[event].append(callback)

    def _trigger_callback(self, event: str, *args):
        """Trigger all callbacks for an event."""
        if event in self.callbacks:
            for callback in self.callbacks[event]:
                try:
                    callback(*args)
                except Exception as e:
                    print(f"Callback error ({event}): {e}", file=sys.stderr)

    def _log(self, level: str, message: str):
        """Internal logging with callback support."""
        if not self.gui_mode:
            print(message)
        self._trigger_callback("on_log", level, message)

    # ----------------- GeoIP -----------------

    def _init_geoip(self):
        if not self.geoip_enabled:
            return

        ensure_vendor_on_path()

        try:
            import geoip2.database  # type: ignore
            db_candidates = [os.path.join(BASE_DIR, self.geoip_db_path)]
            if not os.path.isfile(db_candidates[0]):
                # try common alternates relative to script dir
                db_candidates = [
                    os.path.join(BASE_DIR, "GeoLite2-City.mmdb"),
                    os.path.join(BASE_DIR, "GeoLite2-Country.mmdb"),
                ]

            chosen = None
            for p in db_candidates:
                if os.path.isfile(p):
                    chosen = p
                    break

            if chosen:
                self.geoip_reader = geoip2.database.Reader(chosen)
                self.geoip_mode = "geoip2"
                self._log("INFO", f"GeoIP: using geoip2 database at {chosen}")
                return
            else:
                self._log("WARNING", f"GeoIP: geoip2 database not found (tried: {[os.path.basename(x) for x in db_candidates]}); GeoIP lookups disabled.")
        except Exception as e:
            self._log("WARNING", f"GeoIP: geoip2 not available ({e}); GeoIP lookups disabled.")

        self.geoip_mode = None
        self.geoip_reader = None

    def _geoip_country_name(self, ip: str) -> str:
        # Treat private/loopback addresses specially
        try:
            ip_obj = ipaddress.ip_address(ip)
            if ip_obj.is_private or ip_obj.is_loopback:
                return "Local/Private"
        except Exception:
            pass

        if not self.geoip_enabled or self.geoip_reader is None or self.geoip_mode is None:
            return "Unknown"
        try:
            # Use country DB if available, else city
            try:
                resp = self.geoip_reader.country(ip)
                name = resp.country.name or resp.country.iso_code
            except Exception:
                resp = self.geoip_reader.city(ip)
                name = (resp.country.name or resp.country.iso_code or
                        (resp.registered_country.name if getattr(resp, "registered_country", None) else None))
            return name or "Unknown"
        except Exception:
            return "Unknown"

    # ----------------- Utility -----------------

    def _timestamp(self) -> str:
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def _parse_server_line(self, line):
        line = line.strip()
        if not line or line.startswith("#"):
            return None
        if ":" not in line:
            return None
        host, port_str = line.split(":", 1)
        host = host.strip()
        port_str = port_str.strip()
        try:
            port = int(port_str)
            if not (0 < port < 65536):
                return None
        except ValueError:
            return None
        return host, port

    def _resolve_host(self, host):
        try:
            # Resolve to IPv4 string and split into octets
            ip_str = socket.gethostbyname(host)
            octets = ip_str.split(".")
            if len(octets) != 4:
                return None
            return bytes(int(o) & 0xFF for o in octets)
        except Exception:
            return None

    def _sanitized_bind_host(self, host: str) -> str:
        """
        Return a host suitable for binding:
        - If host is invalid (e.g., not on a local interface), return "0.0.0.0".
        """
        try:
            ip = socket.gethostbyname(host)
        except Exception:
            return "0.0.0.0"

        # Try binding a temp socket to verify it's a local interface
        test = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            test.bind((ip, 0))
            return ip
        except Exception:
            return "0.0.0.0"
        finally:
            try:
                test.close()
            except Exception:
                pass

    # ----------------- Packet building -----------------

    def _build_packets_from_servers(self, servers):
        """
        Build a list of UDP payloads for CS 1.6 masterserver response.
        Each packet starts with GOLDSRC_HEADER and contains N * 6 server entries.
        Optionally ends with 6 zero bytes if NOPING == 0.
        Packet size kept under MAX_PACKET_SIZE.
        """
        packets = []
        current = bytearray(GOLDSRC_HEADER)

        for host, port in servers:
            ip_bytes = self._resolve_host(host)
            if not ip_bytes:
                continue
            port_hi = (port >> 8) & 0xFF
            port_lo = port & 0xFF
            entry = ip_bytes + bytes([port_hi, port_lo])

            # If adding this entry would exceed MAX_PACKET_SIZE, flush current packet
            trailer_len = 0 if self.noping else len(TRAILER_NOPING_OFF)
            if len(current) + len(entry) + trailer_len > MAX_PACKET_SIZE:
                if trailer_len:
                    current += TRAILER_NOPING_OFF
                packets.append(bytes(current))
                current = bytearray(GOLDSRC_HEADER)

            current += entry

        # Flush the final packet if it has any entries beyond the header
        if len(current) > len(GOLDSRC_HEADER):
            if not self.noping:
                current += TRAILER_NOPING_OFF
            packets.append(bytes(current))

        return packets

    def load_servers(self):
        """
        Load server list from file or database and rebuild response packets.
        """
        servers = []
        
        if self.mode == "database" and self.db:
            # Load from database
            try:
                servers = self.db.get_all_servers(enabled_only=True)
                self._log("INFO", f"Loaded {len(servers)} servers from database")
            except Exception as e:
                self._log("ERROR", f"Failed to load from database: {e}")
                servers = []
        else:
            # Load from file
            try:
                with open(os.path.join(BASE_DIR, self.file_cs), "r", encoding="utf-8") as f:
                    lines = f.readlines()
                
                for line in lines:
                    parsed = self._parse_server_line(line)
                    if parsed:
                        servers.append(parsed)
                        
                self._log("INFO", f"Loaded {len(servers)} servers from file")
            except FileNotFoundError:
                self._log("ERROR", f'FILECS "{self.file_cs}" not found. No servers loaded.')
                servers = []

        if self.randomize:
            random.shuffle(servers)

        packets = self._build_packets_from_servers(servers)

        with self._packet_lock:
            self.cs_packets = packets

        self._log("SUCCESS", f"Loaded {len(servers)} CS 1.6 servers into {len(packets)} packet(s).")
        self._trigger_callback("on_server_loaded", len(servers))
        
        return servers

    def get_servers(self) -> List[Tuple[str, int]]:
        """Get current server list from file or database."""
        if self.mode == "database" and self.db:
            try:
                return self.db.get_all_servers(enabled_only=False)
            except Exception as e:
                self._log("ERROR", f"Failed to get servers from database: {e}")
                return []
        else:
            try:
                with open(os.path.join(BASE_DIR, self.file_cs), "r", encoding="utf-8") as f:
                    lines = f.readlines()
                servers = []
                for line in lines:
                    parsed = self._parse_server_line(line)
                    if parsed:
                        servers.append(parsed)
                return servers
            except Exception:
                return []

    def save_servers(self, servers: List[Tuple[str, int]]) -> bool:
        """Save server list to file or database."""
        if self.mode == "database" and self.db:
            try:
                # Clear existing and add new
                self.db.clear_all()
                for host, port in servers:
                    self.db.add_server(host, port)
                self._log("SUCCESS", f"Saved {len(servers)} servers to database")
                return True
            except Exception as e:
                self._log("ERROR", f"Failed to save servers to database: {e}")
                self._trigger_callback("on_error", "save", str(e))
                return False
        else:
            try:
                with open(os.path.join(BASE_DIR, self.file_cs), "w", encoding="utf-8") as f:
                    f.write("# CS 1.6 Server List\n")
                    f.write("# Add your servers here, one per line in the format: IP:PORT\n\n")
                    for host, port in servers:
                        f.write(f"{host}:{port}\n")
                self._log("SUCCESS", f"Saved {len(servers)} servers to {self.file_cs}")
                return True
            except Exception as e:
                self._log("ERROR", f"Failed to save servers: {e}")
                self._trigger_callback("on_error", "save", str(e))
                return False

    # ----------------- Logging -----------------

    def _looks_like_goldsrc_request(self, data: bytes) -> bool:
        # Basic heuristic: historical client requests include these substrings
        return (b"cstrike" in data) and (b"0.0.0.0:0" in data)

    def _should_log(self, ip: str) -> bool:
        """
        Return True if we should log a line for this IP now.
        - When ONCE_PER_IP = 1: log only once per runtime (first time we see the IP)
        - When ONCE_PER_IP = 0: throttle to one line per THROTTLE_SECONDS
        """
        with self._log_lock:
            if self.log_once_per_ip:
                if ip in self._logged_ips:
                    return False
                self._logged_ips.add(ip)
                return True
            else:
                now = time.monotonic()
                last = self._log_recent.get(ip)
                if last is None or (now - last) >= self.log_throttle_seconds:
                    self._log_recent[ip] = now
                    return True
                return False

    def _log_player_geo(self, ip: str):
        country = self._geoip_country_name(ip)
        
        # Record in statistics
        if self.stats:
            self.stats.record_request(ip, country)
        
        # Trigger callback
        self._trigger_callback("on_request", ip, country)
        
        # Log if appropriate
        if self._should_log(ip):
            ts = self._timestamp()
            self._log("PLAYER", f"Player {ip} from country {country} loaded the server list at {ts}")

    # ----------------- Networking -----------------

    def _windows_udp_connreset_fix(self, sock: socket.socket):
        # Prevent WinError 10054 on UDP (ICMP 'port unreachable' turning into WSAECONNRESET)
        if platform.system().lower().startswith("win"):
            try:
                SIO_UDP_CONNRESET = 0x9800000C
                sock.ioctl(SIO_UDP_CONNRESET, struct.pack('I', 0))
            except Exception:
                pass

    def _bind_listening_socket(self):
        """
        Bind UDP socket robustly:
        - Sanitize host (fallback to 0.0.0.0 if invalid)
        - On errors, try fallback host and a small range of ports to ensure "first run = online"
        """
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # Allow quick restart
        try:
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        except Exception:
            pass

        self._windows_udp_connreset_fix(self.sock)

        host = self._sanitized_bind_host(self.host)
        if host != self.host:
            self._log("WARNING", f'Configured HOST "{self.host}" is not valid on this machine; falling back to {host}')
            self.host = host

        # First try the configured port, then try a fallback range
        candidates = [self.port] + [p for p in range(27010, 27030) if p != self.port]

        last_error = None
        for p in candidates:
            try:
                self.sock.bind((self.host, p))
                if p != self.port:
                    self._log("WARNING", f"Port {self.port} busy or invalid; bound to fallback port {p}")
                self.port = p
                return
            except OSError as e:
                last_error = e
                winerr = getattr(e, "winerror", None) or getattr(e, "errno", None)
                # 10049: The requested address is not valid in its context
                # Try fallback to 0.0.0.0 once more if not already
                if winerr == 10049 and self.host != "0.0.0.0":
                    self.host = "0.0.0.0"
                    continue
                # 10048: Address already in use -> try next port
                if winerr == 10048:
                    continue
                # Other errors: try next candidate
                continue

        # If we get here, all attempts failed
        raise last_error if last_error else OSError("Unable to bind UDP socket")

    def _handle_request(self, data, addr):
        """
        Respond to GoldSrc master list requests and log GeoIP info.
        """
        try:
            if self._looks_like_goldsrc_request(data):
                self._log_player_geo(addr[0])
                with self._packet_lock:
                    packets = list(self.cs_packets)
                
                packets_sent = 0
                for p in packets:
                    try:
                        self.sock.sendto(p, addr)
                        packets_sent += 1
                        time.sleep(0.02)
                    except OSError as e:
                        winerr = getattr(e, "winerror", None) or getattr(e, "errno", None)
                        # Ignore common transient send errors on UDP
                        if winerr in (10054,):
                            continue
                        self._log("ERROR", f"Send error to {addr}: {e}")
                        if self.stats:
                            self.stats.record_error("send")
                
                # Record packets sent
                if self.stats:
                    self.stats.record_packets_sent(packets_sent)
                    
        except Exception as e:
            # Log and continue serving
            self._log("ERROR", f"Handler error for {addr}: {e}")
            self._trigger_callback("on_error", "handler", str(e))
            if self.stats:
                self.stats.record_error("handler")

    def serve(self):
        """
        Main UDP server loop on HOST:PORTGS.
        """
        self._bind_listening_socket()
        self.sock.settimeout(1.0)

        self._log("SUCCESS", f"CS 1.6 masterserver (FILE mode) listening on {self.host}:{self.port}")
        self._log("INFO", "Press Ctrl+C to stop.")
        self._trigger_callback("on_status_change", "running")

        try:
            while not self.stop_event.is_set():
                try:
                    data, addr = self.sock.recvfrom(2048)
                except socket.timeout:
                    continue
                except OSError as e:
                    winerr = getattr(e, "winerror", None) or getattr(e, "errno", None)
                    # Suppress common Windows socket errors
                    # 10054 = Connection reset by peer (UDP noise)
                    # 10038 = Socket operation on non-socket (during shutdown)
                    # 10004 = Interrupted function call (during shutdown)
                    if winerr in (10054, 10038, 10004):
                        # If stop event is set, this is expected during shutdown
                        if self.stop_event.is_set():
                            break
                        continue
                    self._log("ERROR", f"Socket error: {e}")
                    if self.stats:
                        self.stats.record_error("socket")
                    continue
                except Exception as e:
                    # Catch any other errors during shutdown
                    if self.stop_event.is_set():
                        break
                    self._log("ERROR", f"Unexpected error: {e}")
                    continue

                self._handle_request(data, addr)
        finally:
            try:
                if self.sock:
                    self.sock.close()
            except Exception:
                pass
            self.sock = None

    def auto_reloader(self):
        """
        Periodically reloads the server list based on REFRESH interval.
        """
        if self.refresh <= 0:
            return
        while not self.stop_event.is_set():
            for _ in range(self.refresh):
                if self.stop_event.is_set():
                    return
                time.sleep(1)
            try:
                self.load_servers()
            except Exception as e:
                self._log("ERROR", f"Reload error: {e}")
                self._trigger_callback("on_error", "reload", str(e))

    def run(self):
        # Initial load
        self._trigger_callback("on_status_change", "starting")
        self.load_servers()
        # Start reloader thread
        t_reload = threading.Thread(target=self.auto_reloader, daemon=True)
        t_reload.start()
        # Serve in main thread
        self.serve()

    def stop(self):
        self._trigger_callback("on_status_change", "stopping")
        self.stop_event.set()
        
        # Give a moment for the serve loop to detect stop_event
        import time
        time.sleep(0.1)
        
        # Close socket to unblock recv (if still waiting)
        if self.sock:
            try:
                self.sock.close()
            except Exception:
                # Ignore errors during socket close - might already be closed
                pass
            self.sock = None
        
        # Close geoip reader if needed
        try:
            if self.geoip_mode == "geoip2" and self.geoip_reader:
                self.geoip_reader.close()
        except Exception:
            pass
        
        # Close database connection if needed
        if self.db:
            try:
                self.db.close()
            except Exception:
                pass
        
        self._trigger_callback("on_status_change", "stopped")


def main():
    ensure_vendor_on_path()
    server = MasterServer()
    try:
        server.run()
    except KeyboardInterrupt:
        print("\nShutting down...")
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
    finally:
        try:
            server.stop()
        except Exception:
            pass
        print("Stopped.")


if __name__ == "__main__":
    main()

